@@ -6167,11 +6170,11 @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,
 		return -EACCES;
 	}
 
-	if (ptr_reg->type & PTR_MAYBE_NULL) {
-		verbose(env, "R%d pointer arithmetic on %s prohibited, null-check it first\n",
-			dst, reg_type_str(env, ptr_reg->type));
-		return -EACCES;
-	}
+	// if (ptr_reg->type & PTR_MAYBE_NULL) {
+	// 	verbose(env, "R%d pointer arithmetic on %s prohibited, null-check it first\n",
+	// 		dst, reg_type_str(env, ptr_reg->type));
+	// 	return -EACCES;
+	// }
 
 	switch (base_type(ptr_reg->type)) {
 	case CONST_PTR_TO_MAP:
@@ -6184,13 +6187,13 @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,
 	case PTR_TO_SOCK_COMMON:
 	case PTR_TO_TCP_SOCK:
 	case PTR_TO_XDP_SOCK:
-reject:
-		verbose(env, "R%d pointer arithmetic on %s prohibited\n",
-			dst, reg_type_str(env, ptr_reg->type));
-		return -EACCES;
+// reject:
+// 		verbose(env, "R%d pointer arithmetic on %s prohibited\n",
+// 			dst, reg_type_str(env, ptr_reg->type));
+// 		return -EACCES;
 	default:
-		if (type_may_be_null(ptr_reg->type))
-			goto reject;
+		// if (type_may_be_null(ptr_reg->type))
+		// 	goto reject;
 		break;
 	}
@@ -7884,16 +7887,16 @@ static void mark_ptr_or_null_reg(struct bpf_func_state *state,
 {
 	if (type_may_be_null(reg->type) && reg->id == id &&
 	    !WARN_ON_ONCE(!reg->id)) {
-		if (WARN_ON_ONCE(reg->smin_value || reg->smax_value ||
-				 !tnum_equals_const(reg->var_off, 0) ||
-				 reg->off)) {
-			/* Old offset (both fixed and variable parts) should
-			 * have been known-zero, because we don't allow pointer
-			 * arithmetic on pointers that might be NULL. If we
-			 * see this happening, don't convert the register.
-			 */
-			return;
-		}
+		// if (WARN_ON_ONCE(reg->smin_value || reg->smax_value ||
+		// 		 !tnum_equals_const(reg->var_off, 0) ||
+		// 		 reg->off)) {
+		// 	/* Old offset (both fixed and variable parts) should
+		// 	 * have been known-zero, because we don't allow pointer
+		// 	 * arithmetic on pointers that might be NULL. If we
+		// 	 * see this happening, don't convert the register.
+		// 	 */
+		// 	return;
+		// }
 		if (is_null) {
 			reg->type = SCALAR_VALUE;
 		} else if (base_type(reg->type) == PTR_TO_MAP_VALUE) {